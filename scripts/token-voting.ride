{-# STDLIB_VERSION 6 #-}
{-# CONTENT_TYPE DAPP #-}
{-# SCRIPT_TYPE ACCOUNT #-}

let initializedKey = "initialized"
let availableOptionsKey = "available_options"
let votingAssetKey = "voting_asset"
let startHeightKey = "start_height"
let endHeightKey = "end_height"
let totalKey = "total"
let quorumPercentKey = "quorum_percent"
let quorumKey = "quorum"
let votedKey = "voted"

func getStringOrFail(key: String) = match getString(this, key) {
    case s: String => s
    case _ => throw("Key not exist")
}

func getIntOrFail(key: String) = match getInteger(this, key) {
    case i: Int => i
    case _ => throw("Key not exist")
}

func getAssetOrFail(asset: String) = match assetInfo(asset.fromBase58String()) {
    case a: Asset => a
    case _ => throw("Asset not exist")
}

func getBoolOrFalse(key: String) = match getBoolean(this, key) {
    case b: Boolean => b
    case _ => false
}

func getIntOrZero(key: String) = match getInteger(this, key) {
    case i: Int => i
    case _ => 0
}

func userBalanceKey(userAddress: String) = makeString(["balance", userAddress], "_")

@Callable(i)
func constructor(availableOptions: String, votingAsset: String, startHeight: Int, endHeight: Int, quorumPercent: Int) = {
    let payments = i.payments.size()
    let initialized = getBoolOrFalse(initializedKey)
    if (i.caller != this) then { throw("Access denied") }
    else if (payments != 0) then { throw("Payments are prohibited") }
    else if (initialized) then { throw("Already initialized") }
    else if (startHeight > endHeight) then { throw("Start height can't be larger than end height") }
    else if (quorumPercent < 1 || quorumPercent > 99) then { throw("Quorum percent should be in range [1, 99]") }
    else {
        let votingAssetInfo = getAssetOrFail(votingAsset)
        let quorum = fraction(votingAssetInfo.quantity, quorumPercent, 100)
        [
            BooleanEntry(initializedKey, true),
            StringEntry(availableOptionsKey, availableOptions),
            StringEntry(votingAssetKey, votingAsset),
            IntegerEntry(startHeightKey, startHeight),
            IntegerEntry(endHeightKey, endHeight),
            IntegerEntry(totalKey, votingAssetInfo.quantity),
            IntegerEntry(quorumPercentKey, quorumPercent),
            IntegerEntry(quorumKey, quorum),
            IntegerEntry(votedKey, 0)
        ]
    }
}

@Callable(i)
func put() = {
    let payments = i.payments.size()
    let initialized = getBoolOrFalse(initializedKey)
    let payment = i.payments[0].value()
    let votingAssetId = getStringOrFail(votingAssetKey).fromBase58String()
    let startHeight = getIntOrFail(startHeightKey)
    let endHeight = getIntOrFail(endHeightKey)
    if (i.caller == this) then { throw("Access denied") }
    else if (payments != 1) then { throw("Only one payment is allowed") }
    else if (!initialized) then { throw("Not initialized") }            
    else if (payment.assetId != votingAssetId) then { throw("Wrong asset") }
    else if (height < startHeight) then { throw("Voting is not started") }
    else if (height > endHeight) then { throw("Voting is over") }
    else {
        let userAddress = toString(i.caller)
        let currentUserBalance = getIntOrZero(userBalanceKey(userAddress))
        let newUserBalance = currentUserBalance + payment.amount
        [IntegerEntry(userBalanceKey(userAddress), newUserBalance)]
    }
}

@Callable(i)
func castVote(selectedOptions: String) = {
    [StringEntry("hello", "world")]
}

@Callable(i)
func withdraw() = {
    let payments = i.payments.size()
    let initialized = getBoolOrFalse(initializedKey)
    let startHeight = getIntOrFail(startHeightKey)
    let endHeight = getIntOrFail(endHeightKey)
    if (i.caller == this) then { throw("Access denied") }
    else if (payments != 0) then { throw("Payments are prohibited") }
    else if (!initialized) then { throw("Not initialized") }
    else if (height < startHeight) then { throw("Voting is not started") }
    else if (height <= endHeight) then { throw("Voting is not over") }
    else {
        let userAddress = toString(i.caller)
        let userBalance = getIntOrFail(userBalanceKey(userAddress))
        let votingAsset = getStringOrFail(votingAssetKey).fromBase58String()
        [
            ScriptTransfer(i.caller, userBalance, votingAsset),
            DeleteEntry(userBalanceKey(userAddress))
        ]
    }
}

@Verifier(tx)
func verify() = sigVerify(tx.bodyBytes, tx.proofs[0], tx.senderPublicKey)
